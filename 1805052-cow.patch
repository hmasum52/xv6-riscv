diff --git a/Makefile b/Makefile
index 39a99d7..c20bd84 100644
--- a/Makefile
+++ b/Makefile
@@ -132,6 +132,8 @@ UPROGS=\
 	$U/_grind\
 	$U/_wc\
 	$U/_zombie\
+	$U/_cowtest\
+	$U/_cow3 \
 
 fs.img: mkfs/mkfs README $(UPROGS)
 	mkfs/mkfs fs.img README $(UPROGS)
diff --git a/kernel/defs.h b/kernel/defs.h
index a3c962b..37e931e 100644
--- a/kernel/defs.h
+++ b/kernel/defs.h
@@ -63,6 +63,10 @@ void            ramdiskrw(struct buf*);
 void*           kalloc(void);
 void            kfree(void *);
 void            kinit(void);
+// int             k_increase_ref_cnt(void *);
+int             k_increase_ref_cnt(uint64);
+void*           alloc_cow_page(pagetable_t, uint64);
+int            k_pages_in_freelist(void);
 
 // log.c
 void            initlog(int, struct superblock*);
@@ -106,6 +110,7 @@ void            yield(void);
 int             either_copyout(int user_dst, uint64 dst, void *src, uint64 len);
 int             either_copyin(void *dst, int user_src, uint64 src, uint64 len);
 void            procdump(void);
+void            stats(void);
 
 // swtch.S
 void            swtch(struct context*, struct context*);
@@ -173,6 +178,7 @@ uint64          walkaddr(pagetable_t, uint64);
 int             copyout(pagetable_t, uint64, char *, uint64);
 int             copyin(pagetable_t, char *, uint64, uint64);
 int             copyinstr(pagetable_t, char *, uint64, uint64);
+int             check_if_cow(pagetable_t, uint64);
 
 // plic.c
 void            plicinit(void);
diff --git a/kernel/kalloc.c b/kernel/kalloc.c
index 0699e7e..2c2f375 100644
--- a/kernel/kalloc.c
+++ b/kernel/kalloc.c
@@ -14,6 +14,11 @@ void freerange(void *pa_start, void *pa_end);
 extern char end[]; // first address after kernel.
                    // defined by kernel.ld.
 
+struct{
+  int cnt[PHYSTOP/PGSIZE];
+  struct spinlock lock;
+} phy_addr_ref;
+
 struct run {
   struct run *next;
 };
@@ -27,6 +32,7 @@ void
 kinit()
 {
   initlock(&kmem.lock, "kmem");
+  initlock(&phy_addr_ref.lock, "phy_addr_ref");
   freerange(end, (void*)PHYSTOP);
 }
 
@@ -35,8 +41,13 @@ freerange(void *pa_start, void *pa_end)
 {
   char *p;
   p = (char*)PGROUNDUP((uint64)pa_start);
-  for(; p + PGSIZE <= (char*)pa_end; p += PGSIZE)
+  for(; p + PGSIZE <= (char*)pa_end; p += PGSIZE){
+    // in kfree, 1 will be subtracted from cnt[]
+    // here it must be set to 1 first, otherwise it will be
+    // reduced to a negative number
+    phy_addr_ref.cnt[(uint64)p / PGSIZE] = 1;
     kfree(p);
+  }
 }
 
 // Free the page of physical memory pointed at by pa,
@@ -51,6 +62,14 @@ kfree(void *pa)
   if(((uint64)pa % PGSIZE) != 0 || (char*)pa < end || (uint64)pa >= PHYSTOP)
     panic("kfree");
 
+  acquire(&phy_addr_ref.lock);
+  phy_addr_ref.cnt[(uint64)pa / PGSIZE]--;
+  if(phy_addr_ref.cnt[(uint64)pa / PGSIZE] > 0){
+    release(&phy_addr_ref.lock);
+    return;
+  }
+  release(&phy_addr_ref.lock);
+
   // Fill with junk to catch dangling refs.
   memset(pa, 1, PGSIZE);
 
@@ -72,11 +91,95 @@ kalloc(void)
 
   acquire(&kmem.lock);
   r = kmem.freelist;
-  if(r)
+  if(r){
     kmem.freelist = r->next;
+    acquire(&phy_addr_ref.lock);
+    phy_addr_ref.cnt[(uint64)r / PGSIZE] = 1;
+    release(&phy_addr_ref.lock);
+  }
   release(&kmem.lock);
 
+ /*  acquire(&phy_addr_ref.lock);
+  if(r)
+    phy_addr_ref.cnt[(uint64)r / PGSIZE] = 1;
+  release(&phy_addr_ref.lock); */
+
   if(r)
     memset((char*)r, 5, PGSIZE); // fill with junk
   return (void*)r;
 }
+
+int k_increase_ref_cnt(uint64 pa){
+  //if (((uint64)pa % PGSIZE) != 0 || (char *)pa < end || (uint64)pa >= PHYSTOP)
+  if ((pa % PGSIZE) != 0 || (char *)pa < end || pa >= PHYSTOP)
+    return -1;
+  acquire(&phy_addr_ref.lock);
+  ++phy_addr_ref.cnt[pa / PGSIZE];
+  release(&phy_addr_ref.lock);
+  return 0;
+}
+
+void *alloc_cow_page(pagetable_t pagetable, uint64 va)
+{
+  if (va % PGSIZE != 0)
+    // panic("alloc_cow_page: va is not page aligned");
+    return 0; // error
+
+  pte_t *pte;
+  if ((pte = walk(pagetable, va, 0)) == 0)
+    // panic("alloc_cow_page: pte should exist");
+    return 0; // error
+
+  uint64 pa = PTE2PA(*pte);
+
+  if ( phy_addr_ref.cnt[pa/PGSIZE] == 1)
+  {
+    *pte |= PTE_W;
+    *pte &= ~PTE_COW;
+    // only one precess use this page
+    // no need to copy
+    return (void *)pa;
+  }
+
+  char *mem;
+  if ((mem = kalloc()) == 0)
+    // panic("alloc_cow_page: out of memory");
+    return 0; // error
+
+  // copy the content of old page to new page
+  memmove(mem, (char *)pa, PGSIZE);
+
+  // clear PTE_V to avoid remap panic in mappages function
+  *pte &= ~PTE_V;
+
+  int flags = PTE_FLAGS(*pte);
+  flags |= PTE_W;    // enable write for new page
+  flags &= ~PTE_COW; // disable COW for new page
+
+  // map new page
+  if (mappages(pagetable, va, PGSIZE, (uint64)mem, flags) != 0)
+  {
+    kfree(mem);    // free the new page
+    *pte |= PTE_V; // restore the old page
+    return 0;      // error
+  }
+
+  // decrease ref_cnt of old page
+  // will be freed if ref_cnt == 0
+  kfree((char *)PGROUNDDOWN(pa));
+  return mem;
+}
+
+int 
+k_pages_in_freelist(void){
+  int cnt = 0;
+  struct run *r;
+  acquire(&kmem.lock);
+  r = kmem.freelist;
+  while(r){
+    cnt++;
+    r = r->next;
+  }
+  release(&kmem.lock);
+  return cnt;
+}
diff --git a/kernel/proc.c b/kernel/proc.c
index 959b778..05812c9 100644
--- a/kernel/proc.c
+++ b/kernel/proc.c
@@ -681,3 +681,17 @@ procdump(void)
     printf("\n");
   }
 }
+
+// print stats
+void
+stats(void){
+  struct proc *p;
+  int pages_used = 0;
+  for (p = proc; p < &proc[NPROC]; p++){
+    if (p->state == UNUSED)
+      continue;
+    pages_used += p->sz / PGSIZE;
+  }
+  printf("Total pages used: %d\n", pages_used);
+  printf("Total pages in freelist (free pages): %d\n", k_pages_in_freelist());
+}
diff --git a/kernel/riscv.h b/kernel/riscv.h
index 20a01db..2b6ea1f 100644
--- a/kernel/riscv.h
+++ b/kernel/riscv.h
@@ -343,6 +343,7 @@ typedef uint64 *pagetable_t; // 512 PTEs
 #define PTE_W (1L << 2)
 #define PTE_X (1L << 3)
 #define PTE_U (1L << 4) // user can access
+#define PTE_COW (1L << 8) // copy on write
 
 // shift a physical address to the right place for a PTE.
 #define PA2PTE(pa) ((((uint64)pa) >> 12) << 10)
diff --git a/kernel/syscall.c b/kernel/syscall.c
index ed65409..fd112d8 100644
--- a/kernel/syscall.c
+++ b/kernel/syscall.c
@@ -101,6 +101,7 @@ extern uint64 sys_unlink(void);
 extern uint64 sys_link(void);
 extern uint64 sys_mkdir(void);
 extern uint64 sys_close(void);
+extern uint64 sys_stats(void);
 
 // An array mapping syscall numbers from syscall.h
 // to the function that handles the system call.
@@ -126,6 +127,7 @@ static uint64 (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_stats]   sys_stats,
 };
 
 void
diff --git a/kernel/syscall.h b/kernel/syscall.h
index bc5f356..ce75741 100644
--- a/kernel/syscall.h
+++ b/kernel/syscall.h
@@ -20,3 +20,4 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_stats  22
\ No newline at end of file
diff --git a/kernel/sysproc.c b/kernel/sysproc.c
index 1de184e..2513dba 100644
--- a/kernel/sysproc.c
+++ b/kernel/sysproc.c
@@ -89,3 +89,9 @@ sys_uptime(void)
   release(&tickslock);
   return xticks;
 }
+
+uint64 
+sys_stats(void){
+  stats();
+  return 0;
+}
diff --git a/kernel/trap.c b/kernel/trap.c
index 512c850..e0be02b 100644
--- a/kernel/trap.c
+++ b/kernel/trap.c
@@ -65,6 +65,14 @@ usertrap(void)
     intr_on();
 
     syscall();
+  } else if (r_scause() == 15){
+    uint64 va = r_stval(); // va is the faulting virtual address
+    // check if the address is valid
+    if( (va >= p->sz )
+      || check_if_cow(p->pagetable, va) !=0
+      || alloc_cow_page(p->pagetable, PGROUNDDOWN(va)) == 0){
+      setkilled(p);
+    }
   } else if((which_dev = devintr()) != 0){
     // ok
   } else {
diff --git a/kernel/vm.c b/kernel/vm.c
index 9f69783..155e1ff 100644
--- a/kernel/vm.c
+++ b/kernel/vm.c
@@ -308,22 +308,42 @@ uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
   pte_t *pte;
   uint64 pa, i;
   uint flags;
-  char *mem;
+  //char *mem;
 
   for(i = 0; i < sz; i += PGSIZE){
     if((pte = walk(old, i, 0)) == 0)
       panic("uvmcopy: pte should exist");
     if((*pte & PTE_V) == 0)
       panic("uvmcopy: page not present");
+
+    // turn on the cow flag if the page is writable
+    // also turn off the writable flag
+    /* if(*pte & PTE_W){
+       *pte &= ~PTE_W;
+       *pte |= PTE_COW;
+    } */
+
     pa = PTE2PA(*pte);
     flags = PTE_FLAGS(*pte);
-    if((mem = kalloc()) == 0)
-      goto err;
-    memmove(mem, (char*)pa, PGSIZE);
-    if(mappages(new, i, PGSIZE, (uint64)mem, flags) != 0){
-      kfree(mem);
+
+    if( flags & PTE_W ){
+      // flags &= ~PTE_W;
+      // flags |= PTE_COW;
+      flags = (flags | PTE_COW) & ~PTE_W;
+      *pte = PA2PTE(pa) | flags;
+    }
+    
+    //if((mem = kalloc()) == 0)
+    //  goto err;
+    //memmove(mem, (char*)pa, PGSIZE);
+    //if(mappages(new, i, PGSIZE, (uint64)mem, flags) != 0){
+    if(mappages(new, i, PGSIZE, pa, flags) != 0){
+      //kfree(mem);
       goto err;
     }
+    // increase reference count of the page
+    if( (k_increase_ref_cnt(pa)) != 0 )
+      goto err;
   }
   return 0;
 
@@ -345,6 +365,26 @@ uvmclear(pagetable_t pagetable, uint64 va)
   *pte &= ~PTE_U;
 }
 
+int check_if_cow(pagetable_t pagetable, uint64 va){
+  // check if virtual address va is valid
+  if(va >= MAXVA)
+    return -1; // error
+
+  // get page table entry of va
+  pte_t *pte;
+  if((pte = walk(pagetable, va, 0)) == 0)
+    return -1;
+
+  // check if pte is valid
+  if( !(*pte & PTE_V) )
+    return -1; // error
+
+  //check if copy on write flag is set
+  if( !(*pte & PTE_COW) )
+    return -1; // error
+
+  return 0; // va is valid and copy on write flag is set
+}
 // Copy from kernel to user.
 // Copy len bytes from src to virtual address dstva in a given page table.
 // Return 0 on success, -1 on error.
@@ -356,6 +396,9 @@ copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)
   while(len > 0){
     va0 = PGROUNDDOWN(dstva);
     pa0 = walkaddr(pagetable, va0);
+    if(check_if_cow(pagetable, va0)==0){
+      pa0 = (uint64)alloc_cow_page(pagetable, va0);
+    }
     if(pa0 == 0)
       return -1;
     n = PGSIZE - (dstva - va0);
diff --git a/user/cow3.c b/user/cow3.c
new file mode 100644
index 0000000..113f823
--- /dev/null
+++ b/user/cow3.c
@@ -0,0 +1,23 @@
+#include "kernel/types.h"
+#include "kernel/memlayout.h"
+#include "user/user.h"
+
+int main(){
+    int* c = malloc(sizeof(int));
+
+    int pid = fork();
+    stats();
+    if(pid == 0){
+        *c = 1;
+        printf("c = %d\n", *c);
+        stats();
+        exit(0);
+    }
+    else{
+        wait(0);
+        *c = 2;
+        printf("c= %d\n", *c);
+        stats();
+        exit(0);
+    }
+}
\ No newline at end of file
diff --git a/user/cowtest.c b/user/cowtest.c
new file mode 100644
index 0000000..bc32fed
--- /dev/null
+++ b/user/cowtest.c
@@ -0,0 +1,221 @@
+//
+// tests for copy-on-write fork() assignment.
+//https://github.com/mit-pdos/xv6-riscv-fall19/blob/xv6-riscv-fall19/user/cowtest.c
+//
+
+#include "kernel/types.h"
+#include "kernel/memlayout.h"
+#include "user/user.h"
+
+// allocate more than half of physical memory,
+// then fork. this will fail in the default
+// kernel, which does not support copy-on-write.
+void simpletest()
+{
+    uint64 phys_size = PHYSTOP - KERNBASE;
+    int sz = (phys_size / 3) * 2;
+
+    printf("simple: ");
+
+    char *p = sbrk(sz);
+    if (p == (char *)0xffffffffffffffffL)
+    {
+        printf("sbrk(%d) failed\n", sz);
+        exit(-1);
+    }
+
+    for (char *q = p; q < p + sz; q += 4096)
+    {
+        *(int *)q = getpid();
+    }
+
+    int pid = fork();
+    if (pid < 0)
+    {
+        printf("fork() failed\n");
+        exit(-1);
+    }
+
+    if (pid == 0)
+        exit(0);
+
+    wait(0);
+
+    if (sbrk(-sz) == (char *)0xffffffffffffffffL)
+    {
+        printf("sbrk(-%d) failed\n", sz);
+        exit(-1);
+    }
+
+    printf("ok\n");
+}
+
+// three processes all write COW memory.
+// this causes more than half of physical memory
+// to be allocated, so it also checks whether
+// copied pages are freed.
+void threetest()
+{
+    uint64 phys_size = PHYSTOP - KERNBASE;
+    int sz = phys_size / 4;
+    int pid1, pid2;
+
+    printf("three: ");
+
+    char *p = sbrk(sz);
+    if (p == (char *)0xffffffffffffffffL)
+    {
+        printf("sbrk(%d) failed\n", sz);
+        exit(-1);
+    }
+
+    pid1 = fork();
+    if (pid1 < 0)
+    {
+        printf("fork failed\n");
+        exit(-1);
+    }
+    if (pid1 == 0)
+    {
+        pid2 = fork();
+        if (pid2 < 0)
+        {
+            printf("fork failed");
+            exit(-1);
+        }
+        if (pid2 == 0)
+        {
+            for (char *q = p; q < p + (sz / 5) * 4; q += 4096)
+            {
+                *(int *)q = getpid();
+            }
+            for (char *q = p; q < p + (sz / 5) * 4; q += 4096)
+            {
+                if (*(int *)q != getpid())
+                {
+                    printf("wrong content\n");
+                    exit(-1);
+                }
+            }
+            exit(-1);
+        }
+        for (char *q = p; q < p + (sz / 2); q += 4096)
+        {
+            *(int *)q = 9999;
+        }
+        exit(0);
+    }
+
+    for (char *q = p; q < p + sz; q += 4096)
+    {
+        *(int *)q = getpid();
+    }
+
+    wait(0);
+
+    sleep(1);
+
+    for (char *q = p; q < p + sz; q += 4096)
+    {
+        if (*(int *)q != getpid())
+        {
+            printf("wrong content\n");
+            exit(-1);
+        }
+    }
+
+    if (sbrk(-sz) == (char *)0xffffffffffffffffL)
+    {
+        printf("sbrk(-%d) failed\n", sz);
+        exit(-1);
+    }
+
+    printf("ok\n");
+}
+
+char junk1[4096];
+int fds[2];
+char junk2[4096];
+char buf[4096];
+char junk3[4096];
+
+// test whether copyout() simulates COW faults.
+void filetest()
+{
+    printf("file: ");
+
+    buf[0] = 99;
+
+    for (int i = 0; i < 4; i++)
+    {
+        if (pipe(fds) != 0)
+        {
+            printf("pipe() failed\n");
+            exit(-1);
+        }
+        int pid = fork();
+        if (pid < 0)
+        {
+            printf("fork failed\n");
+            exit(-1);
+        }
+        if (pid == 0)
+        {
+            sleep(1);
+            if (read(fds[0], buf, sizeof(i)) != sizeof(i))
+            {
+                printf("error: read failed\n");
+                exit(1);
+            }
+            sleep(1);
+            int j = *(int *)buf;
+            if (j != i)
+            {
+                printf("error: read the wrong value\n");
+                exit(1);
+            }
+            exit(0);
+        }
+        if (write(fds[1], &i, sizeof(i)) != sizeof(i))
+        {
+            printf("error: write failed\n");
+            exit(-1);
+        }
+    }
+
+    int xstatus = 0;
+    for (int i = 0; i < 4; i++)
+    {
+        wait(&xstatus);
+        if (xstatus != 0)
+        {
+            exit(1);
+        }
+    }
+
+    if (buf[0] != 99)
+    {
+        printf("error: child overwrote parent\n");
+        exit(1);
+    }
+
+    printf("ok\n");
+}
+
+int main(int argc, char *argv[])
+{
+    simpletest();
+
+    // check that the first simpletest() freed the physical memory.
+    simpletest();
+
+    threetest();
+    threetest();
+    threetest();
+
+    filetest();
+
+    printf("ALL COW TESTS PASSED\n");
+
+    exit(0);
+}
\ No newline at end of file
diff --git a/user/user.h b/user/user.h
index 4d398d5..f57f9f3 100644
--- a/user/user.h
+++ b/user/user.h
@@ -22,6 +22,7 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int stats(void);
 
 // ulib.c
 int stat(const char*, struct stat*);
diff --git a/user/usys.pl b/user/usys.pl
index 01e426e..2841253 100755
--- a/user/usys.pl
+++ b/user/usys.pl
@@ -36,3 +36,4 @@ entry("getpid");
 entry("sbrk");
 entry("sleep");
 entry("uptime");
+entry("stats")
\ No newline at end of file
